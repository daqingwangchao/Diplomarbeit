/* Automatically generated by p4c-ebpf from PA+bytecounter.p4 on Thu Oct 10 11:08:48 2024
 */
#include "PA+bytecounter.h"
#include "ebpf_kernel.h"
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/in.h>

enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
    ParserInvalidArgument,
};

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, s, v) do { u8 mask = EBPF_MASK(u8, s); *((u8*)a) = ((*((u8*)a)) & ~mask) | (((v) >> (8 - (s))) & mask); } while (0)
#define write_partial_ex(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)
#define PTR_DIFF_BYTES(b, o) (ssize_t)((u8*)(b) - (u8*)(o))

void* memcpy(void* dest, const void* src, size_t num);

#define bpf_trace_message(fmt, ...)

//REGISTER_START()
//REGISTER_TABLE(MyFilter_byte_counter, BPF_MAP_TYPE_ARRAY, u32, MyFilter_byte_counter_value, 1)
//BPF_ANNOTATE_KV_PAIR(MyFilter_byte_counter, u32, MyFilter_byte_counter_value)
//REGISTER_END()

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __type(key, u32);
    __type(value, MyFilter_byte_counter_value);
    __uint(max_entries, 1);
}MyFilter_byte_counter SEC(".maps");

SEC("prog")
int ebpf_filter(SK_BUFF *skb){
    struct headers hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = ((void*)(long)skb->data);
    u8* ebpf_headerStart = ebpf_packetStart;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u8 accept = 0;
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    u32 ebpf_pkt_len = skb->len;

    goto start;
    parse_ipv4: {
/* extract(hdr.ipv4) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(160 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        hdr.ipv4.version = (u8)((load_byte(ebpf_headerStart, BYTES(0)) >> 4) & EBPF_MASK(u8, 4));
        hdr.ipv4.ihl = (u8)((load_byte(ebpf_headerStart, BYTES(4))) & EBPF_MASK(u8, 4));
        hdr.ipv4.diffserv = (u8)((load_byte(ebpf_headerStart, BYTES(8))));
        hdr.ipv4.totalLen = (u16)((load_half(ebpf_headerStart, BYTES(16))));
        hdr.ipv4.identification = (u16)((load_half(ebpf_headerStart, BYTES(32))));
        hdr.ipv4.flags = (u8)((load_byte(ebpf_headerStart, BYTES(48)) >> 5) & EBPF_MASK(u8, 3));
        hdr.ipv4.fragOffset = (u16)((load_half(ebpf_headerStart, BYTES(51))) & EBPF_MASK(u16, 13));
        hdr.ipv4.ttl = (u8)((load_byte(ebpf_headerStart, BYTES(64))));
        hdr.ipv4.protocol = (u8)((load_byte(ebpf_headerStart, BYTES(72))));
        hdr.ipv4.hdrChecksum = (u16)((load_half(ebpf_headerStart, BYTES(80))));
        hdr.ipv4.srcAddr = (u32)((load_word(ebpf_headerStart, BYTES(96))));
        hdr.ipv4.dstAddr = (u32)((load_word(ebpf_headerStart, BYTES(128))));

        hdr.ipv4.ebpf_valid = 1;
        ebpf_headerStart += BYTES(160);

;
         goto accept;
    }
    start: {
/* extract(hdr.ethernet) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(112 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        hdr.ethernet.dstAddr = (u64)((load_dword(ebpf_headerStart, BYTES(0)) >> 16) & EBPF_MASK(u64, 48));
        hdr.ethernet.srcAddr = (u64)((load_dword(ebpf_headerStart, BYTES(48)) >> 16) & EBPF_MASK(u64, 48));
        hdr.ethernet.etherType = (u16)((load_half(ebpf_headerStart, BYTES(96))));

        hdr.ethernet.ebpf_valid = 1;
        ebpf_headerStart += BYTES(112);

;
        u16 select_0;
        select_0 = hdr.ethernet.etherType;
        if (select_0 == 0x800)goto parse_ipv4;
        if ((select_0 & 0x0) == (0x0 & 0x0))goto accept;
        else goto reject;
    }

    reject: {
        return TC_ACT_SHOT;
    }

    accept:
    {
    void *data = (void *)(long)skb->data;
    void *data_end = (void *)(long)skb->data_end;
    
    struct ethhdr *eth = data;
    if ((void*)(eth + 1) > data_end)
        goto original_processing;
        
    struct iphdr *ip = (void*)(eth + 1);
    if ((void*)(ip + 1) > data_end)
        goto original_processing;
        
    // 保存修改前的IP头部，用于后续更新
    struct iphdr ip_cpy = *ip;

//    bpf_trace_printk("Processing packet to IP: %x, Proto: %d\n", 
//                     ip->daddr, ip->protocol);
        
    if (ip->protocol == IPPROTO_TCP) {
        struct tcphdr *tcp = (void*)(ip + 1);
        if ((void*)(tcp + 1) > data_end)
            goto original_processing;

//        // 添加端口调试信息
//        bpf_trace_printk("TCP ports - src: %d, dst: %d\n", 
//                        bpf_ntohs(tcp->source), bpf_ntohs(tcp->dest));
            
        // 检查是否为HTTP流量(80端口)
        if (bpf_ntohs(tcp->dest) == 80) {
            // 计算payload偏移量
            int payload_offset = sizeof(*eth) + (ip->ihl * 4) + (tcp->doff * 4);
            
            // 验证payload区域
            char http_header[8];
            if (bpf_skb_load_bytes(skb, payload_offset, http_header, 7) < 0)
                goto original_processing;

            // 打印前几个字节用于调试
//            bpf_trace_printk("HTTP start: %c%c%c%c\n", 
//                           http_header[0], http_header[1], 
//                           http_header[2], http_header[3]);
                
            // 检查是否为GET请求
            if (http_header[0] == 'G' && http_header[1] == 'E' && 
                http_header[2] == 'T' && http_header[3] == ' ') {
                
                // 添加自定义headers
                char new_headers[] = "X-BPF-Node: worker-1\r\n"
                                   "X-BPF-Timestamp: 123456\r\n";
                
                // 在HTTP头部之前插入
                if (bpf_skb_store_bytes(skb, 
                                   payload_offset - 2,
                                   new_headers,
                                   sizeof(new_headers) - 1,
                                   BPF_F_RECOMPUTE_CSUM) < 0)
                    goto original_processing;
                
                // 更新IP总长度
                __u16 old_len = bpf_ntohs(ip_cpy.tot_len);
                __u16 new_len = old_len + sizeof(new_headers) - 1;
                
                // 使用bpf_l3_csum_replace更新IP校验和
                if (bpf_l3_csum_replace(skb, 
                                      offsetof(struct iphdr, check),
                                      old_len,
                                      new_len,
                                      2) < 0)
                    goto original_processing;
                
                // 使用bpf_skb_store_bytes更新IP总长度
                __u16 new_len_network = bpf_htons(new_len);
                if (bpf_skb_store_bytes(skb,
                                      offsetof(struct iphdr, tot_len),
                                      &new_len_network,
                                      sizeof(__u16),
                                      0) < 0)
                    goto original_processing;
            }
        }
    }

original_processing:    
        u8 hit;
        {
if (/* hdr.ethernet.isValid() */
            hdr.ethernet.ebpf_valid) {
if (/* hdr.ipv4.isValid() */
                hdr.ipv4.ebpf_valid) {
/* byte_counter_0.add(0, (u32)hdr.ipv4.totalLen) */
{
                        MyFilter_byte_counter_value *value_0;
                        MyFilter_byte_counter_value init_val = 1;
                        MyFilter_byte_counter_key key_0 = 0;
                        MyFilter_byte_counter_value inc = (u32)hdr.ipv4.totalLen;
                        value_0 = BPF_MAP_LOOKUP_ELEM(MyFilter_byte_counter, &key_0);
                        if (value_0 != NULL)
                            __sync_fetch_and_add(value_0, inc);
                        else
                            BPF_MAP_UPDATE_ELEM(MyFilter_byte_counter, &key_0, &init_val, BPF_ANY);
                    }
;
                                        accept = true;
                }
                else {
                    accept = true;                }
            }

            else {
                accept = true;            }

        }
    }
    ebpf_end:
    if (accept)
        return TC_ACT_OK;
    else
        return TC_ACT_SHOT;
}
char _license[] SEC("license") = "GPL";
