/* Automatically generated by p4c-ebpf from packetProcessor.p4 on Mon Sep  2 15:53:14 2024
 */
#ifndef _P4_GEN_HEADER_
#define _P4_GEN_HEADER_
#include "ebpf_kernel.h"

#define MAP_PATH "/sys/fs/bpf/tc/globals"
struct ethernet_t {
    u64 dstAddr; /* macAddr_t */
    u64 srcAddr; /* macAddr_t */
    u16 etherType; /* bit<16> */
    u8 ebpf_valid;
};

struct ipv4_t {
    u8 version; /* bit<4> */
    u8 ihl; /* bit<4> */
    u8 diffserv; /* bit<8> */
    u16 totalLen; /* bit<16> */
    u16 identification; /* bit<16> */
    u8 flags; /* bit<3> */
    u16 fragOffset; /* bit<13> */
    u8 ttl; /* bit<8> */
    u8 protocol; /* bit<8> */
    u16 hdrChecksum; /* bit<16> */
    u32 srcAddr; /* ip4Addr_t */
    u32 dstAddr; /* ip4Addr_t */
    u8 ebpf_valid;
};

struct headers {
    struct ethernet_t ethernet; /* ethernet_t */
    struct ipv4_t ipv4; /* ipv4_t */
};

struct MyFilter_ipv4_filter_key {
    u32 field0; /* hdr.ipv4.srcAddr */
    u32 field1; /* hdr.ipv4.dstAddr */
    u8 field2; /* hdr.ipv4.protocol */
} __attribute__((aligned(4)));
#define MAX_MYFILTER_IPV4_FILTER_KEY_MASKS 128
struct MyFilter_ipv4_filter_key_mask {
    __u8 mask[sizeof(struct MyFilter_ipv4_filter_key)];
} __attribute__((aligned(4)));
#define MYFILTER_IPV4_FILTER_ACT_MYFILTER_ALLOW 1
#define MYFILTER_IPV4_FILTER_ACT_MYFILTER_DROP 2
#define MYFILTER_IPV4_FILTER_ACT_MYFILTER_COUNT_BYTES 3
struct MyFilter_ipv4_filter_value {
    unsigned int action;
    __u32 priority;
    union {
        struct {
        } _NoAction;
        struct {
        } MyFilter_allow;
        struct {
        } MyFilter_drop;
        struct {
            u32 index;
        } MyFilter_count_bytes;
    } u;
};
struct MyFilter_ipv4_filter_value_mask {
    __u32 tuple_id;
    struct MyFilter_ipv4_filter_key_mask next_tuple_mask;
    __u8 has_next;
};
typedef u32 MyFilter_byte_counter_key;
typedef u32 MyFilter_byte_counter_value;
#if CONTROL_PLANE
static void init_tables() 
{
    u32 ebpf_zero = 0;
    {
        int tableFileDescriptor = BPF_OBJ_GET(MAP_PATH "/MyFilter_ipv4_filter_defaultAction");
        if (tableFileDescriptor < 0) { fprintf(stderr, "map MyFilter_ipv4_filter_defaultAction not loaded\n"); exit(1); }
        struct MyFilter_ipv4_filter_value value = {
            .action = MYFILTER_IPV4_FILTER_ACT_MYFILTER_ALLOW,
            .u = {.MyFilter_allow = {}},
        };
        int ok = BPF_USER_MAP_UPDATE_ELEM(tableFileDescriptor, &ebpf_zero, &value, BPF_ANY);
        if (ok != 0) { perror("Could not write in MyFilter_ipv4_filter_defaultAction"); exit(1); }
    }
}
#endif
#endif
