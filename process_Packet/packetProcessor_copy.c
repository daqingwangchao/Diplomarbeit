/* Automatically generated by p4c-ebpf from packetProcessor.p4 on Mon Sep  2 15:53:14 2024
 */
#include "packetProcessor.h"
#include "ebpf_kernel.h"

enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
    ParserInvalidArgument,
};

// Use a simpler format string for bpf_trace_printk
#define bpf_debug(fmt, ...)                            \
    ({                                                 \
        char ____fmt[] = fmt;                          \
        bpf_trace_printk(____fmt, sizeof(____fmt),     \
                         ##__VA_ARGS__);               \
    })

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, s, v) do { u8 mask = EBPF_MASK(u8, s); *((u8*)a) = ((*((u8*)a)) & ~mask) | (((v) >> (8 - (s))) & mask); } while (0)
#define write_partial_ex(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)
#define PTR_DIFF_BYTES(b, o) (ssize_t)((u8*)(b) - (u8*)(o))

void* memcpy(void* dest, const void* src, size_t num);

#define bpf_trace_message(fmt, ...)

//REGISTER_START()
//REGISTER_TABLE(MyFilter_ipv4_filter_prefixes, BPF_MAP_TYPE_HASH, struct MyFilter_ipv4_filter_key_mask, struct MyFilter_ipv4_filter_value_mask, 1024)
//BPF_ANNOTATE_KV_PAIR(MyFilter_ipv4_filter_prefixes, struct MyFilter_ipv4_filter_key_mask, struct MyFilter_ipv4_filter_value_mask)
//REGISTER_TABLE_INNER(MyFilter_ipv4_filter_tuple, BPF_MAP_TYPE_HASH, struct MyFilter_ipv4_filter_key, struct MyFilter_ipv4_filter_value, 1024, 1, 1)
//BPF_ANNOTATE_KV_PAIR(MyFilter_ipv4_filter_tuple, struct MyFilter_ipv4_filter_key, struct MyFilter_ipv4_filter_value)
//REGISTER_TABLE_OUTER(MyFilter_ipv4_filter_tuples_map, BPF_MAP_TYPE_ARRAY_OF_MAPS, __u32, __u32, 1024, 1, MyFilter_ipv4_filter_tuple)
//BPF_ANNOTATE_KV_PAIR(MyFilter_ipv4_filter_tuples_map, __u32, __u32)
//REGISTER_TABLE(MyFilter_ipv4_filter_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct MyFilter_ipv4_filter_value, 1)
//BPF_ANNOTATE_KV_PAIR(MyFilter_ipv4_filter_defaultAction, u32, struct MyFilter_ipv4_filter_value)
//REGISTER_TABLE(MyFilter_byte_counter, BPF_MAP_TYPE_ARRAY, u32, MyFilter_byte_counter_value, 256)
//BPF_ANNOTATE_KV_PAIR(MyFilter_byte_counter, u32, MyFilter_byte_counter_value)
//REGISTER_END()
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, struct MyFilter_ipv4_filter_key_mask);
    __type(value, struct MyFilter_ipv4_filter_value_mask);
    __uint(max_entries, 1024);
} MyFilter_ipv4_filter_prefixes SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, struct MyFilter_ipv4_filter_key);
    __type(value, struct MyFilter_ipv4_filter_value);
    __uint(max_entries, 1024);
} MyFilter_ipv4_filter_tuple SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __type(key, u32);
    __type(value, struct MyFilter_ipv4_filter_value);
    __uint(max_entries, 1);
} MyFilter_ipv4_filter_defaultAction SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __type(key, MyFilter_byte_counter_key);
    __type(value, MyFilter_byte_counter_value);
    __uint(max_entries, 256);
} MyFilter_byte_counter SEC(".maps");

SEC("prog")
int ebpf_filter(SK_BUFF *skb){
    struct headers hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = ((void*)(long)skb->data);
    u8* ebpf_headerStart = ebpf_packetStart;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u8 accept = 0;
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    u32 ebpf_pkt_len = skb->len;

    goto start;
    parse_ipv4: {
/* extract(hdr.ipv4) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(160 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        hdr.ipv4.version = (u8)((load_byte(ebpf_headerStart, BYTES(0)) >> 4) & EBPF_MASK(u8, 4));
        hdr.ipv4.ihl = (u8)((load_byte(ebpf_headerStart, BYTES(4))) & EBPF_MASK(u8, 4));
        hdr.ipv4.diffserv = (u8)((load_byte(ebpf_headerStart, BYTES(8))));
        hdr.ipv4.totalLen = (u16)((load_half(ebpf_headerStart, BYTES(16))));
        hdr.ipv4.identification = (u16)((load_half(ebpf_headerStart, BYTES(32))));
        hdr.ipv4.flags = (u8)((load_byte(ebpf_headerStart, BYTES(48)) >> 5) & EBPF_MASK(u8, 3));
        hdr.ipv4.fragOffset = (u16)((load_half(ebpf_headerStart, BYTES(51))) & EBPF_MASK(u16, 13));
        hdr.ipv4.ttl = (u8)((load_byte(ebpf_headerStart, BYTES(64))));
        hdr.ipv4.protocol = (u8)((load_byte(ebpf_headerStart, BYTES(72))));
        hdr.ipv4.hdrChecksum = (u16)((load_half(ebpf_headerStart, BYTES(80))));
        hdr.ipv4.srcAddr = (u32)((load_word(ebpf_headerStart, BYTES(96))));
        hdr.ipv4.dstAddr = (u32)((load_word(ebpf_headerStart, BYTES(128))));

        hdr.ipv4.ebpf_valid = 1;
        ebpf_headerStart += BYTES(160);

        // After parsing IPv4 header
        //if (hdr.ipv4.ebpf_valid) {
        //    bpf_trace_printk("IPv4: src=%x, dst=%x, proto=%d, ttl=%d\n", 
        //                    hdr.ipv4.srcAddr, hdr.ipv4.dstAddr, hdr.ipv4.protocol, hdr.ipv4.ttl);
        //}

;
         goto accept;
    }
    start: {
/* extract(hdr.ethernet) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(112 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        hdr.ethernet.dstAddr = (u64)((load_dword(ebpf_headerStart, BYTES(0)) >> 16) & EBPF_MASK(u64, 48));
        hdr.ethernet.srcAddr = (u64)((load_dword(ebpf_headerStart, BYTES(48)) >> 16) & EBPF_MASK(u64, 48));
        hdr.ethernet.etherType = (u16)((load_half(ebpf_headerStart, BYTES(96))));

        hdr.ethernet.ebpf_valid = 1;
        ebpf_headerStart += BYTES(112);

        // After parsing Ethernet header
        //bpf_trace_printk("Ethernet: src=%llx, dst=%llx, type=0x%x\n", 
        //             hdr.ethernet.srcAddr, hdr.ethernet.dstAddr, hdr.ethernet.etherType);

;
        u16 select_0;
        select_0 = hdr.ethernet.etherType;
        if (select_0 == 0x800)goto parse_ipv4;
        if ((select_0 & 0x0) == (0x0 & 0x0))goto accept;
        else goto reject;
    }

    reject: {
        return TC_ACT_SHOT;
    }

    accept:
    {
        u8 hit;
        u32 byte_count_0 = 0;
        {
if (/* hdr.ipv4.isValid() */
            hdr.ipv4.ebpf_valid) {
/* ipv4_filter_0.apply() */
                {
                    /* construct key */
                    struct MyFilter_ipv4_filter_key key = {};
                    key.field0 = hdr.ipv4.srcAddr;
                    key.field1 = hdr.ipv4.dstAddr;
                    key.field2 = hdr.ipv4.protocol;
                    /* value */
                    struct MyFilter_ipv4_filter_value *value = NULL;
                    /* perform lookup */
                    struct MyFilter_ipv4_filter_key_mask head = {0};
                    struct MyFilter_ipv4_filter_value_mask *val = bpf_map_lookup_elem(&MyFilter_ipv4_filter_prefixes, &head);
                    if (val && val->has_next != 0) {
                        struct MyFilter_ipv4_filter_key_mask next = val->next_tuple_mask;
                        #pragma clang loop unroll(full)
                        for (int i = 0; i < MAX_MYFILTER_IPV4_FILTER_KEY_MASKS; i++) {
                            struct MyFilter_ipv4_filter_value_mask *v = bpf_map_lookup_elem(&MyFilter_ipv4_filter_prefixes, &next);
                            if (!v) {
                                break;
                            }
                            struct MyFilter_ipv4_filter_key k = {};
                            __u32 *chunk = ((__u32 *) &k);
                            __u32 *mask = ((__u32 *) &next);
                            #pragma clang loop unroll(full)
                            for (int i = 0; i < sizeof(struct MyFilter_ipv4_filter_key_mask) / 4; i++) {
                                chunk[i] = ((__u32 *) &key)[i] & mask[i];
                            }
                            __u32 tuple_id = v->tuple_id;
                            next = v->next_tuple_mask;
                           
                            struct MyFilter_ipv4_filter_value *tuple_entry = bpf_map_lookup_elem(&MyFilter_ipv4_filter_tuple, &k);
                            if (!tuple_entry) {
                                if (v->has_next == 0) {
                                    break;
                                }
                                continue;
                            }
                            if (value == NULL || tuple_entry->priority > value->priority) {
                                value = tuple_entry;
                            }
                            if (v->has_next == 0) {
                                break;
                            }
                        }
                    }
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                        value = BPF_MAP_LOOKUP_ELEM(MyFilter_ipv4_filter_defaultAction, &ebpf_zero);
                    } else {
                        hit = 1;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MYFILTER_IPV4_FILTER_ACT_MYFILTER_ALLOW: 
                                {
                                    accept = true;
                                }
                                break;
                            case MYFILTER_IPV4_FILTER_ACT_MYFILTER_DROP: 
                                {
                                    accept = false;
                                }
                                break;
                            case MYFILTER_IPV4_FILTER_ACT_MYFILTER_COUNT_BYTES: 
                                {
                                    byte_count_0 = (u32)hdr.ipv4.totalLen;
                                    //byte_counter_0.add(value->u.MyFilter_count_bytes.index, byte_count_0);
                                        u32 index = value->u.MyFilter_count_bytes.index;
                                        MyFilter_byte_counter_value *counter_value = BPF_MAP_LOOKUP_ELEM(MyFilter_byte_counter, &index);
                                        if (counter_value) {
                                            __sync_fetch_and_add(counter_value, byte_count_0);
                                        }
    
                                                                        accept = true;
                                }
                                break;
                            default:
                                return TC_ACT_SHOT;
                        }
                    } else {
                        return TC_ACT_SHOT;
;
                    }
                }
;
                if (accept) {
if (hdr.ipv4.ttl > 1) {
                        //hdr.ipv4.ttl = (hdr.ipv4.ttl + 255); 
                          bpf_debug("Debug: Decremented TTL, old value=%d\n", hdr.ipv4.ttl);  
                          hdr.ipv4.ttl--;
                          bpf_debug("Debug: Decremented TTL, new value=%d\n", hdr.ipv4.ttl);                  
                      }
                
                    else {
/* drop_1() */
{
                            accept = false;
                        };                    }
                }

            }
            else {
                accept = true;            }

        }
    }
    ebpf_end:
    if (accept)
        return TC_ACT_OK;
    else
        return TC_ACT_SHOT;
}
char _license[] SEC("license") = "GPL";
